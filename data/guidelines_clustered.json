[
  {
    "concern": "Kubernetes API Breaking Changes",
    "guideline": "When upgrading Kubernetes dependencies, audit all call sites of validation functions (e.g., ValidateNodeSelector, ValidateResourceRequirements) for signature changes and added parameters. Use build tags or version-specific shims when supporting multiple Kubernetes versions.",
    "rationale": "Breaking changes in core validation functions between Kubernetes versions (e.g., v1.31 to v1.32) create hard compatibility boundaries that prevent compilation or introduce runtime failures. Code supporting multiple cluster versions must abstract these differences to maintain upgrade-safety and avoid forcing users into immediate major version jumps.",
    "examples": [
      "ValidateNodeSelector gained a required boolean parameter in v1.32 for label value validation",
      "ValidateResourceRequirements renamed to ValidateContainerResourceRequirements between v1.31 and v1.32"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Required Fields and Backward Compatibility",
    "guideline": "When making a field required or changing from pointer to non-pointer type, always provide a defaulting mechanism (mutating webhook, CRD schema defaults, or migration logic) to prevent stored resources from being rejected during upgrade.",
    "rationale": "Changing optional fields to required creates breaking changes that block updates to existing custom resources after operator upgrade, violating Kubernetes API evolution best practices. Without automatic defaulting, users cannot smoothly transition from previous API versions, forcing hard cutovers that can halt cluster operations.",
    "examples": [
      "IstioCSRConfig changed from pointer to non-pointer with required marker blocked upgrades until defaulting was added",
      "Stored objects from earlier operator versions need transition strategy to avoid rejection"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "CEL Validation for Creates vs Updates",
    "guideline": "Always guard CEL immutability checks (self == oldSelf) with create detection logic, since oldSelf is null during resource creation. Prefer native boolean types over string-based \"true\"/\"false\" values in API fields.",
    "rationale": "CEL validations that compare self to oldSelf will fail during creation when oldSelf is null, blocking legitimate resource creation. Using native boolean types eliminates ambiguity, reduces user error from typos or case variations, and integrates more cleanly with Kubernetes tooling than string conventions.",
    "examples": [
      "CEL immutability validation self == oldSelf requires create guard to prevent null reference",
      "Switching from string \"true\"/\"false\" to boolean type improves validation clarity"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Documentation-Schema Alignment",
    "guideline": "Ensure documentation constraints (maxLength, format, allowed values) exactly match CRD schema validation rules. Treat mismatches as critical correctness bugs that erode user trust.",
    "rationale": "Inconsistencies between documented limits and actual schema validation cause deployment failures when users rely on incorrect documentation. This creates upgrade-safety risks and technical debt, as operators may attempt configurations that fail validation unexpectedly at runtime.",
    "examples": [
      "Documentation incorrectly stated 253 characters for namespace while schema correctly enforced Kubernetes limit of 63 characters"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Standard Error Handling Patterns",
    "guideline": "Use k8s.io/apimachinery/pkg/api/errors package for all Kubernetes API error handling. Always check and handle errors explicitly; never ignore errors from API operations.",
    "rationale": "Unhandled errors from Kubernetes API operations lead to silent failures and unpredictable behavior, especially during upgrades or configuration changes. The standard errors package provides idiomatic utilities (IsNotFound, IsAlreadyExists, IsConflict) that improve diagnostics and make code familiar to Kubernetes developers.",
    "examples": [
      "Using standard Kubernetes errors package instead of ignoring API operation errors",
      "Proper error checking prevents cascading issues during resource operations"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Reconciliation Loop Ordering",
    "guideline": "Place state-changing operations before validation checks in reconciliation loops to ensure the controller can re-reconcile when validation failures are corrected.",
    "rationale": "Incorrect ordering where validation precedes state changes can create stuck states where fixing validation issues doesn't trigger recovery. Proper ordering follows standard Kubernetes reconciliation patterns and prevents the need for manual operator intervention after validation failures are resolved.",
    "examples": [
      "Moving action before validation to allow re-reconciliation after validation fixes",
      "Preventing stuck states during upgrades when validation rules temporarily fail"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "YAML Templating Correctness",
    "guideline": "In Helm charts, place conditionals on separate lines, not inline. Always quote template values to prevent type coercion issues. Validate all templates with yamllint before commit.",
    "rationale": "Improper YAML templating syntax causes deployment failures that only surface at install time. Quoting template values prevents unexpected parsing behaviors across different Kubernetes versions and Helm rendering contexts, while consistent formatting reduces cognitive load and establishes patterns for extensibility.",
    "examples": [
      "Fixing conditionals improperly placed inline rather than on separate lines",
      "Adding quoted template values to prevent type coercion during Helm rendering"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Nil Pointer Safety for Optional Fields",
    "guideline": "Always nil-check pointer fields (especially deployment.Spec.Replicas and similar optional Kubernetes fields) before dereferencing. Establish and reuse consistent defensive patterns across similar functions.",
    "rationale": "Dereferencing pointer fields without nil checks causes runtime panics when fields aren't explicitly set or when Kubernetes defaulting behavior changes across versions. Consistent nil-handling patterns improve maintainability and make helper functions reliable across various resource configurations.",
    "examples": [
      "deployment.Spec.Replicas requires nil check before dereferencing",
      "Adopting defensive nil-handling pattern from verifyDeploymentReplicas across similar functions"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Standard Library Preference",
    "guideline": "Use k8s.io/apimachinery standard library functions (e.g., meta.FindStatusCondition) instead of custom implementations for common Kubernetes operations.",
    "rationale": "Standard library functions are well-tested, handle edge cases consistently with the Kubernetes ecosystem, and evolve with API conventions. Using them reduces custom maintenance burden, improves code familiarity for contributors, and automatically receives upstream bug fixes and optimizations.",
    "examples": [
      "Using meta.FindStatusCondition instead of custom condition-finding logic",
      "Leveraging standard library for consistency with Kubernetes API patterns"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Version Downgrade Prevention",
    "guideline": "Never downgrade component versions (e.g., cert-manager 1.24.6 to 1.24.4) in production operators without explicit documentation, migration testing, and strong justification. Treat unexpected version decreases as critical defects.",
    "rationale": "Downgrading versions violates forward-only upgrade assumptions in Kubernetes controllers and can corrupt state written by newer versions, introduce regressions, or break API compatibility. Users following normal upgrade paths will encounter undefined behavior without explicit downgrade documentation and testing.",
    "examples": [
      "Questioning potential cert-manager-operator downgrade from 1.24.6 to 1.24.4",
      "Version rollbacks require explicit testing to avoid breaking existing installations"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Configuration Source Fidelity",
    "guideline": "When fixing generated configuration (bindata, templated YAML), always update the source files rather than just the generated output. Use standard Kubernetes label conventions (e.g., kubernetes.io/metadata.name) instead of ad-hoc labels.",
    "rationale": "Fixing only generated files causes changes to be overwritten during regeneration, creating recurring bugs. Using standard platform labels ensures functionality works as expected and makes configurations discoverable and debuggable for operators familiar with platform conventions.",
    "examples": [
      "Updating source YAML in bindata instead of generated file to prevent overwrite",
      "Changing namespaceSelector from incorrect 'name' label to standard 'kubernetes.io/metadata.name'"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "Design Decision Documentation",
    "guideline": "Document non-obvious design choices, validation patterns, and architectural constraints directly in code comments or ADRs. Explain the reasoning behind specific implementations, especially for immutability rules and feature flags.",
    "rationale": "Explicit documentation of design rationale prevents unnecessary refactoring, accidental removal of important patterns, and helps future maintainers understand constraints without archaeological investigation. This is critical in operators where upgrade paths and behaviors must remain consistent across versions.",
    "examples": [
      "Documenting why double-space in error messages is intentional when object name is empty",
      "Explaining reasoning behind verbose per-feature CEL validation when concise expressions aren't supported"
    ],
    "cluster_id": "api-validation-and-upgrade-compatibility"
  },
  {
    "concern": "incomplete-review-data",
    "guideline": "All PR review comments must include sufficient context: the actual comment text, relevant diff showing code changes, and identified architectural concerns to enable meaningful technical assessment.",
    "rationale": "Without complete review context, architectural analysis cannot assess correctness, upgrade-safety, maintainability, ease-of-use, performance tradeoffs, or extensibility. This cluster represents a systematic breakdown in the review data collection or transmission process. Complete context is required for reviewers and automated systems to provide actionable feedback and maintain architectural quality standards.",
    "examples": [
      "Review submissions containing only metadata (id, empty concerns array) without actual comment text or diff",
      "Messages showing 'I don't see any PR review comment provided' indicating missing required fields",
      "Incomplete data where comment section is cut off or empty after 'Comment:' label"
    ],
    "cluster_id": "missing-review-context"
  },
  {
    "concern": "review-tooling-validation",
    "guideline": "Review collection systems must validate that required fields (comment text, diff context, concerns) are present and non-empty before submitting review data for architectural analysis.",
    "rationale": "This cluster reveals a tooling or process gap where review data is being collected without proper validation. Implementing input validation ensures that architectural review workflows receive actionable data and prevents wasted analysis cycles on incomplete submissions. This improves review efficiency and ensures consistent quality in architectural governance.",
    "examples": [
      "Automated systems accepting review submissions with null or empty comment fields",
      "Review collection forms that allow submission without required diff context",
      "Integration pipelines that forward incomplete review data to analysis systems"
    ],
    "cluster_id": "missing-review-context"
  },
  {
    "concern": "timeout-configuration-isolation",
    "guideline": "Implement explicit, isolated timeout configurations per test suite rather than relying on global values that can be inadvertently overridden by local scopes.",
    "rationale": "Local timeout configurations can shadow global settings without clear intent, causing flaky tests and upgrade failures when health checks complete prematurely. This creates non-obvious behavior where tests pass inconsistently due to race conditions. Proper timeout scoping prevents context deadline exceeded errors and ensures predictable test execution across different environments.",
    "examples": [
      "A local 5-second timeout overriding global health verification duration causing premature failures",
      "Timeout changes cascading unexpectedly across multiple test suites due to tight coupling",
      "Reverting to empirically validated older timeout values to restore test stability"
    ],
    "cluster_id": "test-infrastructure-and-timeouts"
  },
  {
    "concern": "condition-matching-completeness",
    "guideline": "Design condition matching logic to evaluate all relevant conditions per operand rather than short-circuiting on the first match, ensuring comprehensive health verification.",
    "rationale": "Prematurely exiting after finding one degradation condition can mask additional failures, creating false negatives that undermine operational reliability. Systems may report healthy status while deployment-level degradation exists. Comprehensive condition checking prevents masked operational problems during upgrades and runtime, improving both correctness and maintainability.",
    "examples": [
      "Matching '-static-resources-Degraded' and stopping without evaluating '-deploymentDegraded'",
      "Adding MatchAny and MatchAll patterns to support flexible condition verification semantics",
      "Introducing dedicated unit tests for condition verify functions to document expected behavior"
    ],
    "cluster_id": "test-infrastructure-and-timeouts"
  },
  {
    "concern": "test-utility-reusability",
    "guideline": "Extract duplicated test logic into shared utility functions and adopt API-based object creation for simple dynamic resources while reserving templates for complex static configurations.",
    "rationale": "Code duplication across test suites creates maintenance burden and risks divergent implementations over time. Template-based creation becomes unwieldy for simple objects requiring many runtime values, obscuring intent. A hybrid approach using programmatic construction for dynamic simple objects and templates for complex static resources improves type safety, discoverability, and reduces technical debt.",
    "examples": [
      "Extracting repeated helper functions from multiple test suites into centralized utilities",
      "Shifting from WithTemplateValues to API-based creation for issuers and certificates with dynamic runtime values",
      "Scoping refactoring incrementally (e.g., only testdata/acme) to avoid risky wholesale changes"
    ],
    "cluster_id": "test-infrastructure-and-timeouts"
  },
  {
    "concern": "test-image-tag-conventions",
    "guideline": "Maintain consistent use of 'latest' image tags in test manifests to preserve CI automation contracts that automatically substitute image references during testing.",
    "rationale": "CI infrastructure depends on predictable tag conventions to automatically replace image references across test suites. Deviating from 'latest' requires manual synchronization of multiple configuration files for every release, introducing coordination overhead and potential for human error. Preserving this convention reduces fragile coupling between release processes and CI automation, ensuring reliable continuous integration.",
    "examples": [
      "CI system breaking when explicit tags are used instead of 'latest' because automated image replacement fails",
      "Requiring manual tag updates in CI config files for every release when deviating from convention"
    ],
    "cluster_id": "test-infrastructure-and-timeouts"
  },
  {
    "concern": "upgrade-path-safety",
    "guideline": "Enforce mandatory intermediate upgrade steps through specific versions when breaking changes or migrations require sequential state transformations, documenting the rationale and preserving historical workarounds.",
    "rationale": "Direct version jumps can skip critical intermediate transformations, causing data corruption or operational failures. Requiring intermediate steps (e.g., through 1.13.1 before 1.14.0) ensures controlled migration paths and prevents bypassing necessary state changes. Preserving 'skips' fields and workarounds for buggy versions maintains upgrade guardrails, prioritizing operational safety over code cleanliness despite increased technical debt.",
    "examples": [
      "Requiring users to upgrade through version 1.13.1 before reaching 1.14.0",
      "Implementing non-standard z-stream upgrade paths to circumvent known issues like OCPBUGS-56758",
      "Preserving 'skips' field workarounds to prevent upgrades through problematic versions"
    ],
    "cluster_id": "test-infrastructure-and-timeouts"
  },
  {
    "concern": "tech-preview-gating",
    "guideline": "Disable TechPreview features by default and enforce this through automated testing; defer enabling experimental controllers cluster-wide until GA maturity with performance validation.",
    "rationale": "Automatically enabled experimental features expose users to stability risks and breaking changes during upgrades. Default-disabled posture with test enforcement prevents accidental enablement and serves as living documentation. Enabling controllers universally before understanding resource costs wastes cluster resources for users who don't utilize the functionality. Performance profiling should inform final enablement decisions at GA.",
    "examples": [
      "Adding test cases to verify TechPreview features are disabled by default",
      "Deferring default-enabled controller decision until feature reaches GA and performance impact is understood",
      "Protecting users from compatibility risks of incomplete experimental implementations"
    ],
    "cluster_id": "test-infrastructure-and-timeouts"
  },
  {
    "concern": "dependency-version-currency",
    "guideline": "Upgrade third-party dependencies to versions free of known CVEs before deployment; separate test environment version currency from production requirements to balance stability with security.",
    "rationale": "Deploying dependencies with known vulnerabilities (e.g., Vault 1.19.0 with CVE-2025-3879, CVE-2025-4656) creates immediate security debt and compliance failures. Test environments don't require the same aggressive version tracking as production, allowing validation in controlled settings before production deployment. This separation reduces CI/CD churn while maintaining reasonable production-parity without breaking tests from unexpected upstream changes.",
    "examples": [
      "Rejecting Vault 1.19.0 due to authentication bypass and DoS vulnerabilities, recommending 1.19.6 or 1.21.0",
      "Maintaining slightly older versions in test environments to avoid unnecessary disruption while staying reasonably current"
    ],
    "cluster_id": "test-infrastructure-and-timeouts"
  },
  {
    "concern": "validation-constraints-safety",
    "guideline": "Design validation rules with append-only or deletion-restricted constraints when configuration references may be in use by system components, explicitly documenting the tradeoff between safety and user flexibility.",
    "rationale": "Allowing deletion of in-use configuration entries (e.g., revision lists) can break existing deployments and references during rollouts. Append-only constraints with hard caps (e.g., max 10 revisions) prevent accidental breakage and ensure backward compatibility, though they limit user autonomy in managing lifecycle. This tradeoff prioritizes correctness and upgrade safety over ease-of-use, requiring clear documentation of operational implications when limits are reached.",
    "examples": [
      "Preventing deletion from revision lists to avoid breaking references, allowing only appends up to 10 entries",
      "Hard caps providing performance boundaries while creating operational challenges when limits are reached"
    ],
    "cluster_id": "test-infrastructure-and-timeouts"
  },
  {
    "concern": "port-and-resource-allocation",
    "guideline": "Maintain a centralized registry of allocated ports and resource identifiers across all operator components. Validate port assignments during CI to detect conflicts before merge.",
    "rationale": "Port conflicts between components (e.g., health endpoints, metrics) cause deployment-time failures that are difficult to debug in production. Without systematic tracking, conflicts emerge during upgrades when new services are added or existing ones are modified. Centralized allocation prevents resource contention and ensures monitoring and health check endpoints remain functional across component evolution.",
    "examples": [
      "Port 9403 conflict between cert-manager-controller health endpoint and new service",
      "Need for documented port allocation strategy to prevent future collisions"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "cross-component-version-synchronization",
    "guideline": "Document and automate synchronization mechanisms for shared dependencies (Go versions, library versions) between operator and operand repositories. Capture update procedures in repository documentation, not external channels.",
    "rationale": "Version drift between operator and operand causes subtle build failures and runtime incompatibilities during upgrades. Relying on Slack threads or tribal knowledge creates onboarding barriers and increases risk of forgotten update steps. Automated checks or CI validation ensure consistent build environments and prevent deployment of incompatible component combinations.",
    "examples": [
      "Go version synchronization between operator and jetstack-cert-manager fork requiring <carry> patches",
      "Critical dependency updates documented only in Slack rather than repository"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "crd-naming-and-api-contracts",
    "guideline": "Enforce strict adherence to Kubernetes naming conventions for CRDs (plural.group format). Validate CRD names and API references in CI against established patterns to prevent installation failures.",
    "rationale": "Malformed CRD names (e.g., omitting resource plural prefix) cause immediate installation failures and prevent Kubernetes from mapping resources to API groups. Inconsistent API naming breaks reconciliation loops, automation scripts, and upgrade paths. Validation during build ensures API contracts remain stable and discoverable across operator versions.",
    "examples": [
      "CRD named 'acme.cert-manager.io' instead of correct 'challenges.acme.cert-manager.io'",
      "API name 'certmanagers' consistency required for proper resource reconciliation"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "immutability-enforcement",
    "guideline": "Enforce documented immutability constraints programmatically using x-kubernetes-validations CEL rules at the CRD level. Do not rely solely on documentation to communicate API contracts.",
    "rationale": "Unenforced immutability constraints allow users to modify fields that cause runtime inconsistencies or upgrade failures. Documentation-only contracts increase support burden and risk of misconfiguration. CEL validation provides admission-time enforcement that is self-documenting and prevents invalid states from entering the cluster, improving both correctness and operator experience.",
    "examples": [
      "Missing x-kubernetes-validations for immutable defaultNetworkPolicy and networkPolicies fields",
      "Overly strict Bundle CRD validation blocking CREATE operations that should only apply to UPDATEs"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "early-validation-vs-runtime-errors",
    "guideline": "Prefer upfront validation of configuration at admission time over runtime detection, especially for lightweight checks. Balance strictness with usability by validating at CREATE for correctness, relaxing for UPDATE only when needed for compatibility.",
    "rationale": "Early validation catches configuration errors before deployment, reducing troubleshooting burden and preventing production failures. Lightweight validation (e.g., CA configuration checks) has negligible performance impact but significantly improves user experience through fail-fast behavior. Consistent validation patterns across the codebase improve maintainability and predictability.",
    "examples": [
      "Retaining early CA validation despite it being optional, for immediate error feedback",
      "Removing CREATE-time validation on Bundle PrivateKey while keeping UPDATE-time compatibility checks"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "naming-convention-consistency",
    "guideline": "Establish and enforce consistent naming conventions for similar concepts across all APIs (log levels, resource types, configuration fields). Document conventions in architecture guidelines and validate in code review.",
    "rationale": "Inconsistent naming (e.g., different log level vocabularies across components) fragments the user experience and increases cognitive load. Operators must remember multiple conventions for the same concept, breaking automation and configuration management tools. Consistency improves maintainability by making the codebase intuitive and reduces support burden from confused users.",
    "examples": [
      "Log level naming must align with established {Normal, Debug, Trace, TraceAll} pattern",
      "Vault authentication path constants mixing full API path format with mount-name-only format"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "leader-election-stability",
    "guideline": "Use version-independent, stable lease identifiers for leader election. Never change lease names across operator versions unless providing explicit migration logic to prevent split-brain scenarios during upgrades.",
    "rationale": "Changing lease names between versions causes multiple operator instances to believe they are leader simultaneously during rolling upgrades, breaking distributed coordination guarantees. Split-brain scenarios lead to reconciliation conflicts, race conditions, and data corruption. Stable lease naming or explicit migration ensures exactly-one-leader semantics throughout the operator lifecycle.",
    "examples": [
      "Lease name change from 'istiocsrs' to 'certmanagers' between v1.17.0 and v1.18.0 causing potential dual-leader state"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "manifest-generation-automation",
    "guideline": "Fully automate manifest generation through make targets using declarative tooling (jsonnet, kustomize, helm --dry-run). Never commit manually-edited generated manifests. Enforce through CI checks that make generate produces no diff.",
    "rationale": "Manual manifest edits introduce human error and create inconsistency during upstream rebases. Automated generation provides auditable, repeatable processes that reduce risk of missing changes during upgrades. While maintaining patches against upstream creates rebase overhead, automation ensures patches are consistently applied and traceable, improving long-term operational reliability despite short-term maintenance burden.",
    "examples": [
      "Requiring helm --dry-run + jsonnet filtering for manifest generation instead of manual edits",
      "Enforcing make generate as single source of truth for all derived manifests"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "documentation-code-synchronization",
    "guideline": "Keep documentation examples, comments, and samples synchronized with actual implementation. Use named references (e.g., port names) in both code and docs to maintain single source of truth. Remove obsolete TechPreview samples when features reach GA.",
    "rationale": "Stale documentation creates confusion and support issues when users copy examples that reference outdated port numbers, field names, or configuration patterns. Mismatched documentation reduces trust and increases troubleshooting time. Synchronization is especially critical during feature promotion (TechPreview to GA) to prevent users from following deprecated patterns.",
    "examples": [
      "ServiceMonitor documentation using hard-coded ports instead of named port references",
      "Field comments referencing 'different cert-manager components' (plural) when validation restricts to single value",
      "Legacy TechPreview samples remaining after IstioCSR GA promotion"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "schema-validation-minimums",
    "guideline": "Enforce operational constraints (minimum replica counts, required fields) at the CRD schema level using OpenAPI validation. Complement with runtime validation only when schema constraints are insufficient.",
    "rationale": "Schema-level validation provides immediate feedback at admission time across all API interactions (kubectl, automation, controllers). Missing minimum constraints (e.g., allowing zero replicas) permits invalid states that cause service outages. CRD validation is the most robust approach for preventing invalid configurations and provides better user experience than runtime error detection.",
    "examples": [
      "Missing minimum:1 validation on replica count allowing scale-to-zero scenarios",
      "Adding schema constraint (minimum:1) regenerated in CRD rather than relying only on deployment hook validation"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "error-handling-completeness",
    "guideline": "Check all Kubernetes API operation errors before using retrieved objects. Implement graceful retry logic for transient failures rather than panicking. Align error-handling patterns consistently across codebase.",
    "rationale": "Unchecked errors on Get/List operations cause nil pointer panics when API calls fail due to transient issues or eventual consistency delays. Graceful error handling improves test reliability and prevents flaky failures during CI and upgrades. Consistent error-handling patterns across the codebase improve maintainability and make code easier to review and understand.",
    "examples": [
      "Secret retrieval error not checked before TLS validation logic, causing panic on transient API failures",
      "Need for consistent error handling with retry logic in eventual-consistency scenarios"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "architectural-boundary-preservation",
    "guideline": "Maintain clear ownership boundaries between distinct API resources and operators. Avoid shared configuration state across operator boundaries; prefer duplication over tight coupling when resources have separate reconciliation lifecycles.",
    "rationale": "Sharing configuration between distinct operators (e.g., certmanager.operator.openshift.io and istiocsr.openshift.io) creates tight coupling that hinders independent evolution and complicates upgrade paths. Clear boundaries improve maintainability by ensuring each operator reconciles only its own operands. Minor configuration duplication is acceptable to preserve extensibility and prevent cross-dependency issues.",
    "examples": [
      "Keeping logLevel configuration within istio_csr resource rather than centralizing with certmanager resource",
      "Each operator reconciling only its own operand deployments to maintain separation"
    ],
    "cluster_id": "configuration-validation-and-consistency"
  },
  {
    "concern": "code-generation-synchronization",
    "guideline": "Never manually edit generated code in directories like pkg/operator or generated bindata.go files. Always modify source definitions and regenerate using `make generate` or `make update` to ensure consistency.",
    "rationale": "Manual edits to auto-generated code will be overwritten during the next generation cycle, leading to maintenance problems and inconsistencies between source definitions and runtime artifacts. This creates correctness risks where deployed configurations don't match intended schemas and wastes contributor effort on changes that won't persist. Proper generation hygiene ensures the codebase remains synchronized and reproducible across builds.",
    "examples": [
      "Changes in pkg/operator should be made through `make generate` command",
      "Verify bindata.go regeneration produces no changes after running generation commands",
      "Stale embedded resources could deploy incorrect configurations during operator upgrades"
    ],
    "cluster_id": "pr-hygiene-and-code-generation"
  },
  {
    "concern": "pr-scope-and-organization",
    "guideline": "Keep changes within the correct PR scope. Scripts, code, and commits should be included in the PR where they are architecturally relevant, not mixed into unrelated PRs.",
    "rationale": "Including code changes in incorrect PRs undermines review effectiveness and makes it impossible to understand architectural context and intent. This fragmentation creates git history that doesn't clearly show why changes were introduced, complicates rollbacks during upgrades, and prevents reviewers from assessing changes alongside their related functionality as a cohesive unit. Proper PR organization is critical for maintaining clear change provenance and traceability.",
    "examples": [
      "Script checked into wrong PR when it should have been part of PR #309",
      "Commits that may be unnecessary for the stated PR purpose should be challenged and justified"
    ],
    "cluster_id": "pr-hygiene-and-code-generation"
  },
  {
    "concern": "cross-reference-documentation",
    "guideline": "When referencing previous discussions or enhancement proposals, summarize the key architectural decision or concern directly in the comment rather than relying solely on external links.",
    "rationale": "While cross-referencing creates an audit trail for architectural decisions, it creates barriers for new contributors who must trace through multiple threads to understand context. Comments should balance preserving institutional knowledge through references with making the rationale immediately accessible. This improves maintainability by reducing cognitive load and ensuring critical context isn't lost if external references become unavailable.",
    "examples": [
      "References to PR #293 discussion threads without explaining what was decided",
      "Commit hashes mentioned without describing what was changed or why",
      "API updates referencing enhancement proposals without summarizing the key compatibility implications"
    ],
    "cluster_id": "pr-hygiene-and-code-generation"
  },
  {
    "concern": "dependency-version-selection",
    "guideline": "Always use the latest patch release within a minor version line for dependencies like Go, especially when security fixes are involved. Verify release notes for critical security patches before selecting a version.",
    "rationale": "Using outdated patch releases leaves known vulnerabilities unaddressed, particularly in security-sensitive components like TLS and certificate handling. The latest patch release ensures all stability and security improvements are included with minimal breaking change risk since patches focus on bug fixes rather than API changes. This reduces technical debt from known security issues and improves upgrade safety.",
    "examples": [
      "Prefer Go 1.24.8 over 1.24.6 when 1.24.8 contains critical security patches for crypto/tls and crypto/x509",
      "Check release notes for security fixes in database/sql, os/exec, archive/tar before selecting patch version"
    ],
    "cluster_id": "pr-hygiene-and-code-generation"
  },
  {
    "concern": "upstream-image-alignment",
    "guideline": "Default to official upstream images and community catalog operators unless there are documented technical requirements that cannot be met otherwise. Justify any custom image decisions explicitly in design docs.",
    "rationale": "Custom images require ongoing effort to rebuild, patch, and synchronize with upstream security updates and bug fixes, creating significant operational burden. Using upstream images and catalog operators provides automated updates, established upgrade channels, and better compatibility during cluster upgrades. Diverging from standard images creates upgrade-safety risks and makes it harder to follow supported upgrade paths.",
    "examples": [
      "Question why custom images are used instead of official upstream images",
      "Evaluate whether community operator from catalog could satisfy requirements before building custom solution"
    ],
    "cluster_id": "pr-hygiene-and-code-generation"
  },
  {
    "concern": "configuration-semantic-alignment",
    "guideline": "When exposing operand configuration options, inherit or directly map to the operand's own definitions rather than creating custom abstractions. Document any mapping explicitly or remove the abstraction entirely.",
    "rationale": "Independent configuration taxonomies create semantic mismatches that confuse administrators during troubleshooting and increase cognitive overhead. Custom mappings introduce documentation burden and risk drift as the operand evolves. This is an upgrade-safety concern since operand definition changes could silently break mapping assumptions without clear version compatibility guarantees.",
    "examples": [
      "Operand log levels should align with operand's own log level definitions, not use operator-specific mapping",
      "Either document configuration mapping explicitly or inherit directly from operator configuration"
    ],
    "cluster_id": "pr-hygiene-and-code-generation"
  },
  {
    "concern": "CEL lifecycle gating",
    "guideline": "Always gate CEL immutability rules with `has(oldSelf)` or equivalent checks to prevent validation failures during CREATE operations.",
    "rationale": "CEL validation rules that reference `oldSelf` without checking its existence will fail during resource creation, making the API unusable. This is a critical correctness issue that breaks basic CRUD workflows and prevents valid resource instantiation. Proper lifecycle gating ensures immutability rules only apply to UPDATE operations where previous state exists.",
    "examples": [
      "Use `has(oldSelf) && self != oldSelf` instead of `self == oldSelf` for immutability",
      "Gate with `has(oldSelf) && oldSelf.field != self.field` to allow initial field setting",
      "Presence checks like `has(self.privateKeyAlgorithm)` evaluate true during CREATE when defaults apply, incorrectly blocking creation"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "CEL and defaulting interaction",
    "guideline": "Do not use presence-based CEL rules to enforce field absence during CREATE; rely on immutability rules with oldSelf checks instead.",
    "rationale": "Validation runs before defaults are materialized in the admission chain, causing presence checks to incorrectly reject valid CREATE operations when defaulting is configured. This breaks normal declarative workflows and conflicts with Kubernetes API conventions. Presence validation should be conditional on field existence rather than requiring absence.",
    "examples": [
      "Remove rules like `!has(self.field)` during CREATE that conflict with defaulting",
      "Use compatibility checks conditional on presence: `!has(self.algorithm) || validAlgorithm(self.algorithm)`",
      "Replace presence validation with explicit empty-value checks to permit defaults"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "Cross-field validation",
    "guideline": "Use CEL XValidation rules to enforce algorithm-specific constraints and cross-field dependencies at admission time.",
    "rationale": "Declarative cross-field validation catches invalid configurations at the API boundary before persistence, preventing runtime failures and providing immediate user feedback. This centralizes validation logic in the schema where it's self-documenting and versioned with the API, improving maintainability over scattered controller validation. It enables fail-fast behavior that reduces unnecessary reconciliation attempts.",
    "examples": [
      "Enforce RSA key size constraints: `self.algorithm != 'RSA' || self.keySize in [2048, 4096]`",
      "Validate ECDSA compatibility: `self.algorithm != 'ECDSA' || self.keySize in [256, 384]`",
      "Check mutual exclusivity or required combinations between related fields"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "Conditional immutability",
    "guideline": "When immutability depends on feature enablement or other fields, explicitly gate the CEL rule on the enabling condition.",
    "rationale": "Unconditional immutability rules prevent legitimate pre-activation configuration changes and contradict documented API behavior. Gating immutability on the enabling condition (e.g., feature flag) allows users to iterate on configuration before commitment, improving ease-of-use and aligning code with documentation. This prevents blocking valid use cases like fixing configuration errors during preview phases.",
    "examples": [
      "Gate network policy immutability: `self.defaultNetworkPolicy != 'true' || has(oldSelf) && self.networkPolicies == oldSelf.networkPolicies`",
      "Allow modification until feature is enabled, then enforce immutability",
      "Document the conditional immutability behavior clearly in API field descriptions"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "List mutation semantics",
    "guideline": "Design list validation rules to permit controlled removal when bounded by MaxItems constraints; document whether lists are append-only, immutable, or fully mutable.",
    "rationale": "Append-only list validation combined with MaxItems creates an irreconcilable state where the resource cannot be updated without violating constraints, blocking normal operations and upgrades. Clear mutation semantics prevent user confusion and ensure the API remains operationally viable. Validation should balance data integrity with practical operational needs like pruning old entries.",
    "examples": [
      "Avoid size-only checks like `size(self) >= size(oldSelf)` on bounded lists",
      "If append-only is required, either remove MaxItems or allow controlled removal of oldest entries",
      "Document slice mutation semantics: 'This list is append-only until maxItems is reached, then oldest entries may be removed'"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "Empty value semantics",
    "guideline": "Validate that required reference fields (names, keys) have minimum length constraints, not just presence checks, to prevent empty-string configurations.",
    "rationale": "Presence checks alone permit empty strings for critical fields like ConfigMap names or keys, allowing invalid configurations to pass admission and fail at runtime. Minimum length validation catches these errors earlier in the deployment lifecycle, improving correctness and operational safety. This makes the API contract explicit and reduces ambiguity for users.",
    "examples": [
      "Add `minLength: 1` to Name and Key fields in ConfigMapReference structures",
      "Clarify documentation: 'Key refers to an entry in .data, not .binaryData'",
      "Combine presence with non-empty validation: `has(self.name) && size(self.name) > 0`"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "Validation vs. documented behavior",
    "guideline": "Ensure CEL validation rules precisely match documented API semantics; mismatches between code and documentation must be resolved before release.",
    "rationale": "Ambiguity between validation enforcement and documentation creates dangerous situations where users build automation on incorrect assumptions, leading to production incidents. Weak validation that permits documented-as-forbidden changes or strong validation that blocks documented-as-allowed changes both undermine API correctness and user trust. This mismatch impacts upgrade safety as different interpretations may already exist in the field.",
    "examples": [
      "If documentation claims 'immutable once enabled', validate element-wise immutability, not just slice size",
      "If deny-all-egress requires empty rules, validation must permit empty arrays",
      "Update either validation or documentation to achieve consistency before GA"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "CEL test coverage",
    "guideline": "Require envtest-based functional tests for all CEL validation rules, covering both positive (valid configs accepted) and negative (invalid configs rejected) cases across resource lifecycle stages.",
    "rationale": "CEL validations are the first line of defense for API correctness, but without comprehensive tests, broken rules can ship and either reject valid user input or fail to catch invalid configurations. Tests ensure validation works as intended and prevent regressions during future changes. This is especially critical for the first CEL validation introduced, as it establishes testing patterns for future rules.",
    "examples": [
      "Test CREATE operations to verify immutability rules don't block initial submission",
      "Test UPDATE operations to verify immutability is enforced when oldSelf exists",
      "Test cross-field validation with valid and invalid algorithm/size combinations",
      "Test interaction with defaulting by submitting resources with fields unset"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "API field typing",
    "guideline": "Use pointer types for optional fields to distinguish unset (nil) from explicitly set zero values; use strongly-typed enums or boolean fields over string-based feature flags.",
    "rationale": "Pointer types eliminate ambiguity about user intent and enable backward-compatible defaults when adding new optional fields during API evolution. Strongly-typed fields provide compile-time safety, better IDE support, and clearer API contracts than string enums that rely on runtime validation. While pointers add minor complexity (nil checks), they significantly improve API correctness and upgrade safety.",
    "examples": [
      "Use `*int32` for optional numeric fields to distinguish nil from 0",
      "Replace `FeatureName string` with a struct of boolean fields for discoverability",
      "Document nil vs. zero semantics clearly: 'nil means use default, 0 means explicitly disabled'"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "Validation complexity management",
    "guideline": "Defer complex validation (regex patterns, exhaustive format checks) to future releases when requirements are well-understood and comprehensive tests exist; prioritize simple, correct validation in initial releases.",
    "rationale": "Premature complex validation without adequate test coverage increases risk of rejecting valid inputs or shipping broken rules. Simpler validation reduces immediate maintenance burden and preserves API extensibility by avoiding constraints that may require breaking changes later. This approach prioritizes upgrade safety by allowing validation to evolve as understanding matures, though it shifts some validation burden downstream.",
    "examples": [
      "Remove regex pattern validation if test coverage is insufficient",
      "Start with presence and type validation, add format validation in subsequent releases",
      "Document deferred validation as future work with clear acceptance criteria"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "Validation logic reuse",
    "guideline": "Extract repeated validation logic into shared utility functions or CEL rule libraries rather than duplicating inline checks across multiple callsites.",
    "rationale": "Centralized validation creates a single source of truth, preventing divergent logic that could cause inconsistent behavior or security gaps. Shared functions improve testability by enabling comprehensive isolated testing and make future updates easier and less error-prone. This significantly improves maintainability and correctness as validation requirements evolve.",
    "examples": [
      "Create validateAlgorithmKeySize(algorithm, size) helper for reuse across multiple CRDs",
      "Define common CEL expressions in constants for consistent cross-field validation",
      "Test validation utilities independently with exhaustive input combinations"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "Enhancement proposal alignment",
    "guideline": "Synchronize field naming, validation rules, and API semantics with formally reviewed enhancement proposals before merging implementation PRs.",
    "rationale": "Diverging from community-vetted architectural decisions creates technical debt and may require breaking changes to realign later. Enhancement proposals establish consistent patterns that affect extensibility and ensure implementations follow agreed-upon conventions. This synchronization is critical for upgrade safety and long-term maintainability as the platform evolves.",
    "examples": [
      "Rename fields to match enhancement proposal decisions before API goes GA",
      "Update validation logic to reflect constraints documented in enhancement proposals",
      "Reference enhancement proposal discussions in PR comments to document architectural rationale"
    ],
    "cluster_id": "cel-validation-correctness"
  },
  {
    "concern": "documentation-schema-divergence",
    "guideline": "API documentation, CRD schemas, and runtime validation must be strictly aligned. When conflicts exist, schema constraints take precedence and documentation must be updated to match.",
    "rationale": "Misalignment between documentation and validation creates user confusion, deployment failures, and support burden. Users who configure resources based on documentation will encounter runtime validation errors, breaking trust in the API contract. This pattern appears repeatedly in namespace field constraints (63 vs 253 character limits) and optional field requirements (empty namespace handling).",
    "examples": [
      "istioCACertificate namespace documented as 253 chars but schema enforces 63 chars",
      "Documentation states empty namespace is valid but schema enforces minLength:1",
      "Field documented as optional but schema validation requires it"
    ],
    "cluster_id": "api-schema-validation-alignment"
  },
  {
    "concern": "enum-implementation-completeness",
    "guideline": "CRD enums must only declare values that are fully implemented in validation logic, pod selectors, and controller reconciliation. Remove enum values lacking complete implementation or implement all required handlers before adding to the enum.",
    "rationale": "Advertising API values without backing implementation breaks the API contract and causes runtime failures after schema validation passes. This creates delayed validation feedback, confusing user experiences, and silent failures. The IstioCSR component appears in enums but lacks validation handlers, selector logic, and network policy support.",
    "examples": [
      "IstioCSRComponent in ComponentName enum but missing from validation logic and pod selectors",
      "CRD allows IstioCSR componentName but controller explicitly rejects it at runtime",
      "Network policy controllers only handle CAInjector, CoreController, Webhook but not IstioCSR"
    ],
    "cluster_id": "api-schema-validation-alignment"
  },
  {
    "concern": "required-field-upgrade-safety",
    "guideline": "Converting optional fields to required must include mutating webhook defaulting or explicit migration tooling. Never break existing resources during in-place upgrades.",
    "rationale": "Required field additions without defaults force manual intervention on all existing CRs, breaking zero-downtime upgrades and causing validation failures on stored objects. This severely impacts operational continuity and creates upgrade blockers. Mutating webhooks can automatically backfill values to preserve backward compatibility.",
    "examples": [
      "IstioCSRConfig changed from optional pointer to required value type without defaulting webhook",
      "Existing CRs lacking IstioCSRConfig field would fail validation after upgrade"
    ],
    "cluster_id": "api-schema-validation-alignment"
  },
  {
    "concern": "fail-fast-validation",
    "guideline": "Validation should occur at the earliest possible layer (CRD schema, then admission webhooks, finally controller logic). Never rely solely on controller-level validation for structural constraints.",
    "rationale": "Early validation provides immediate feedback to users and prevents resources from being persisted in invalid states. Deferring validation to controller reconciliation creates delayed failures that are harder to debug and correlate with user actions. CRD schemas provide the first line of defense with clear error messages at submission time.",
    "examples": [
      "IstioCSR passes CRD validation but fails in controller, should be rejected at CRD level",
      "Schema validation contradicts controller validation for namespace emptiness"
    ],
    "cluster_id": "api-schema-validation-alignment"
  },
  {
    "concern": "optional-dependency-resilience",
    "guideline": "Never assume the existence of optional external resources (namespaces, CRDs, services). Include existence checks with graceful degradation or explicit configuration to enable optional features.",
    "rationale": "Hardcoded assumptions about optional components cause reconciliation failures in clusters without those dependencies, blocking upgrades and creating fragile operator behavior. Defensive programming with proper error handling makes operators tolerant of diverse deployment scenarios and prevents cascading failures.",
    "examples": [
      "Assuming istio-system namespace exists without validation",
      "IstioCSR integration lacking feature flag or existence check"
    ],
    "cluster_id": "api-schema-validation-alignment"
  },
  {
    "concern": "experimental-feature-signaling",
    "guideline": "Use explicit 'unsupported' or 'tech-preview' labeling in flags, documentation, and API fields for experimental features. Clearly communicate that these features have no API compatibility guarantees.",
    "rationale": "Explicit stability signals manage user expectations and prevent production dependencies on unstable features. This protects both users from upgrade breakage and maintainers from implicit compatibility obligations. Clear labeling establishes support boundaries and enables faster iteration on experimental functionality.",
    "examples": [
      "Rename flags to --unsupported-addon-features instead of ambiguous names",
      "Document IstioCSR as technical preview with stability warnings"
    ],
    "cluster_id": "api-schema-validation-alignment"
  },
  {
    "concern": "infrastructure-naming-genericity",
    "guideline": "Name shared infrastructure components generically rather than after specific features. Component-specific naming should only apply to isolated, non-reusable code.",
    "rationale": "Tying generic infrastructure names to specific features creates technical debt during refactoring and confuses the architectural boundaries. Generic names improve extensibility by making it clear which code is reusable and reduce coupling between infrastructure and features.",
    "examples": [
      "Using 'istiocsrs' suffix for controller-runtime infrastructure that will be used operator-wide",
      "Feature-specific names for shared reconciliation patterns"
    ],
    "cluster_id": "api-schema-validation-alignment"
  },
  {
    "concern": "crd-sample-discoverability",
    "guideline": "Every CRD must include annotated sample CustomResources in config/samples/. These serve as living documentation, UI examples, and validation test cases.",
    "rationale": "Sample CRs improve ease-of-use by providing working examples, enable OpenShift Console integration via alm-examples annotations, and serve as version-controlled documentation that evolves with API changes. Missing samples increase support burden and make correct configuration harder to discover.",
    "examples": [
      "Missing IstioCSR sample CR for ClusterServiceVersion alm-examples",
      "config/samples directory incomplete for new CRDs"
    ],
    "cluster_id": "api-schema-validation-alignment"
  },
  {
    "concern": "selector-correctness",
    "guideline": "Use the broadest stable label selector that captures all intended components. Prefer `app.kubernetes.io/instance` over `app.kubernetes.io/name` when a single instance deploys multiple components, and always use standard Kubernetes metadata labels like `kubernetes.io/metadata.name` for namespace targeting.",
    "rationale": "Narrow selectors that match only subset of components (e.g., cert-manager controller but not webhook/cainjector) create security gaps and upgrade risks. Standard labels are stable across upgrades and aligned with platform conventions, reducing configuration drift. Overly specific selectors introduce maintenance burden when new components are added.",
    "examples": [
      "Use `app.kubernetes.io/instance: cert-manager` to match controller, webhook, and cainjector pods rather than component-specific labels",
      "Target monitoring namespace with `kubernetes.io/metadata.name: openshift-monitoring` instead of custom labels"
    ],
    "cluster_id": "network-policy-operator-design"
  },
  {
    "concern": "egress-destination-scoping",
    "guideline": "Restrict NetworkPolicy egress rules to explicit destination CIDRs or selectors. Never allow broad port-based rules (e.g., TCP 6443 to any destination) even for well-known service ports.",
    "rationale": "Permissive destination rules mask misconfigurations, violate least-privilege principles, and create compliance risks. While convenient for avoiding IP tracking, they prevent operators from understanding intended communication paths and can hide breaking changes during cluster migrations. The security-performance tradeoff heavily favors restrictive rules.",
    "examples": [
      "Replace 'allow TCP 6443 to 0.0.0.0/0' with explicit API server CIDR blocks or podSelector targeting kube-apiserver",
      "Document and maintain CIDR ranges for external dependencies rather than using wildcard destinations"
    ],
    "cluster_id": "network-policy-operator-design"
  },
  {
    "concern": "resource-lifecycle-management",
    "guideline": "Always set owner references on operator-managed NetworkPolicy objects pointing to their parent custom resource. Ensure the controller watches NetworkPolicy resources to detect and reconcile external modifications.",
    "rationale": "Without owner references, Kubernetes cannot garbage-collect dependent resources, leading to orphaned policies that cause operational confusion and potential conflicts during upgrades. Without watches, the controller cannot detect drift from external changes or deletions, breaking the declarative reconciliation model and requiring manual intervention.",
    "examples": [
      "Add ownerReferences field to generated NetworkPolicy objects referencing the CertManager CR",
      "Include 'Watches(&networkingv1.NetworkPolicy{})' in controller's SetupWithManager to enable drift detection"
    ],
    "cluster_id": "network-policy-operator-design"
  },
  {
    "concern": "naming-collision-safety",
    "guideline": "Generate NetworkPolicy names using a deterministic pattern that includes both component identifier and user-provided name (e.g., `<operator>-user-<component>-<name>`) to prevent collisions and improve operational visibility.",
    "rationale": "Naming conflicts between user-defined and operator-generated policies create ownership ambiguities and potential overwrites during reconciliation. Including component identifiers in names makes affected workloads immediately apparent during troubleshooting, improving debuggability without sacrificing collision safety.",
    "examples": [
      "Use `cert-manager-user-controller-<custom-name>` instead of `cert-manager-user-<custom-name>`",
      "Validate that ComponentName exists and is valid before generating policy names"
    ],
    "cluster_id": "network-policy-operator-design"
  },
  {
    "concern": "immutability-enforcement",
    "guideline": "Enforce documented immutability constraints and security invariants through CEL validation rules (x-kubernetes-validations) at the API level, not just in documentation or controller logic.",
    "rationale": "Documentation-only constraints allow invalid state transitions that violate security models and create dangerous production misconfigurations. API-level validation provides immediate user feedback and prevents silent acceptance of problematic configurations. This is critical for upgrade-safety where security settings must not be downgraded.",
    "examples": [
      "Add CEL rule preventing networkPolicies.enabled from transitioning from true to false",
      "Use 'x-kubernetes-validations: [{rule: \"self == oldSelf || !oldSelf\", message: \"...\" }]' for one-way gates"
    ],
    "cluster_id": "network-policy-operator-design"
  },
  {
    "concern": "validation-coverage",
    "guideline": "Validate structural requirements and field relationships at the API layer rather than deferring to runtime reconciliation. Explicitly validate that referenced components exist and that required fields like podSelector can be deterministically derived.",
    "rationale": "Runtime-only validation increases controller churn and can cause temporary network isolation when invalid configurations are accepted. API-level validation surfaces errors immediately, preventing invalid resources from entering the cluster and reducing debugging complexity. This separation improves performance by avoiding unnecessary reconciliation loops.",
    "examples": [
      "Validate ComponentName exists in allowed set before accepting user-defined NetworkPolicy",
      "Ensure podSelector generation logic is deterministic and validated, not just documented"
    ],
    "cluster_id": "network-policy-operator-design"
  },
  {
    "concern": "documentation-accuracy",
    "guideline": "Maintain strict alignment between API documentation and implementation behavior. Document actual security posture (e.g., 'only egress policies are generated') rather than aspirational or incomplete descriptions.",
    "rationale": "Documentation-code mismatches mislead operators about security posture and create maintainability risks when future developers rely on incorrect comments. Accurate documentation is essential for upgrade-safety as operators depend on it when modifying policies across cluster versions. Misalignment obscures actual permission requirements during troubleshooting.",
    "examples": [
      "Update docs to clarify only egress NetworkPolicies are created when ingress is not implemented",
      "Document why ingress policies are omitted (security reasons) to prevent future confusion"
    ],
    "cluster_id": "network-policy-operator-design"
  },
  {
    "concern": "least-privilege-rbac",
    "guideline": "Define explicit, scoped RBAC permissions based on documented component requirements rather than granting cluster-admin. Reference upstream Helm charts or operator documentation for specific ClusterRole definitions.",
    "rationale": "Overly permissive RBAC violates least-privilege principles, masks actual permission requirements, and creates audit opacity. While cluster-admin improves ease-of-use by avoiding permission failures, it undermines upgrade-safety by making test environments unrepresentative of production RBAC constraints. Scoped permissions improve security posture without meaningful performance tradeoffs.",
    "examples": [
      "Use Vault Helm chart's specific ClusterRoles for server, injector, CSI, and operator components instead of cluster-admin",
      "Document required permissions explicitly to aid production deployment and troubleshooting"
    ],
    "cluster_id": "network-policy-operator-design"
  },
  {
    "concern": "feature-flag-management",
    "guideline": "Manage addon feature configuration through environment variables in OLM Subscription objects rather than hardcoding in operator logic or manifests. Implement robust string validation for environment variable inputs.",
    "rationale": "Centralizing configuration in Subscription objects improves maintainability by providing a single source of truth and aligns with OLM best practices for operator configuration. This pattern enhances extensibility by establishing clear conventions for new features. However, environment variable changes can trigger restarts, and string-based inputs require validation to prevent runtime errors from misconfiguration.",
    "examples": [
      "Define feature flags as environment variables in Subscription spec.config.env rather than operator ConfigMaps",
      "Implement validation for environment variable parsing to fail fast on misconfiguration"
    ],
    "cluster_id": "network-policy-operator-design"
  }
]